unit Unit1;

{$mode ObjFPC}

interface

uses
  Classes, SysUtils;

type
    TData = pointer;
    TAbstractStorage = class                        
        public
            property count: qword read getCount write setCount;
        protected
	    function getData(position: qword): TData; virtual; abstract;
	    function getCount: qword; virtual; abstract;

            procedure setData(position: qword; value: TData); virtual; abstract;
	    procedure setCount(value: qword); virtual; abstract;
        protected
	    property data[position: qword]: TData read getData write setData; default;
    end;

    TMemStorage = class(TAbstractStorage)
        private
	    fdata: array of TData;
        protected
	    function getData(position: qword): TData; override;
	    function getCount: qword; override;

            procedure setData(position: qword; value: TData); override;
	    procedure setCount(value: qword); override;
    end;

    TIntMemStorage = class(TMemStorage)     
        public
	    property dataI[position:qword]: integer read getIData write setIData; default;
        protected
	    function getIData(position: qword): integer;

            procedure setIData(position: qword; value: integer);
    end;

    TFloatMemStorage = class(TMemStorage)
        public
	    property dataF[position: qword]: extended read getfData write setfData; default;

            destructor Destroy; override;
        protected
	    function getfData(position: qword): extended;

            procedure setfData(position: qword; value: extended);
    end;


implementation

function TMemStorage.getData(position: qword): TData;
begin
    if (position >= getCount) then exit(nil);
    Result := fdata[position];
end;
procedure TMemStorage.setData(position: qword; value: TData);
begin
    if (position >= getCount) then
        setCount(position + 1);
    fdata[position] := value;
end;
function TMemStorage.getCount: qword;
begin
    Result := Length(fdata);
end;
procedure TMemStorage.setCount(value: qword);
var old: qword;
begin
    old := getCount;
    setlength(fdata, value);
    for old := old to value-1 do
        fdata[old] := nil;
end;


function TIntMemStorage.getIData(position: qword): integer;
begin
    Result := integer(getData(position));
end;
procedure TIntMemStorage.setIData(position: qword; value: integer);
begin
    setData(position, Pointer(value));
end;


function TFloatMemStorage.getfData(position: qword): extended;
var p: pointer;
begin
    p := data[position];
    if (p = nil) then exit(0);
    Result := extended(p^);
end;
procedure TFloatMemStorage.setfData(position: qword; value: extended);
var p: ^extended;
begin
    if (getData(position) = nil) then
    begin
        p := getmem(sizeof(extended));
        data[position] := p;
    end;
    p := data[position];
    p^ := value;
end;
destructor TFloatMemStorage.Destroy;
var i: integer;
begin
    for i := 0 to getCount-1 do
    begin
        if (data[i] <> nil) then
        begin
            freemem(data[i]);
        end;
    end;
end;










end.

